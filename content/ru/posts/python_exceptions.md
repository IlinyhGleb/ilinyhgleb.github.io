+++
date = '2025-07-01T13:55:57+05:00'
draft = true
title = 'Ошибки. Обработка исключений'
math = true
tags = ["Python", "Информатика", "Основы программирования"]
categories = ['Основы программирования']
courses = ['Основы программирования']
+++

<!--more-->

# Определения

- **Программная ошибка (Баг)** - ошибка при работе программы, приводящая к неверным или неожиданным результатам.
- **Отладка** — этап разработки компьютерной программы, на котором обнаруживают, локализуют и устраняют ошибки.
- **Состояние программы** - содержание всех областей памяти, занятых переменными программы в один конкретный момент времени.

```python
a = 1
x = -6
x = abs(x)
b = 0
b += 1
```

![Состояния](sostoyaniya.png)

# Типы программных ошибок

1. **Синтаксические ошибки** - ошибки в написании кода (неправильные названия, операторы, символы и т.д.). Как правило, на них указывает транслятор или среда разработки.
2. **Логические ошибки** - ошибки в алгоритмах, приводящие к неправильным результатам вычисления. Для проверки требуется сравнение результатов программы с известными результатами.
3. **Опечатки** - могут не нарушать синтаксис и логику алгоритма, но приводить к ошибочным результатам работы. Проверяются с помощью тестирования и проверки программ.

# Анализ программы на ошибки

1. **Статический анализ** - просмотр кода на наличие ошибок без запуска программы. Может выполняться вручную или с помощью специальных инструментов, в том числе встроенных в интегрированную среду разработки.
2. **Динамический анализ** - проверка работоспособности программы в процессе её работы.

# Технологии динамического анализа

> Первоочередная цель анализа: Локализовать ошибку - найти конкретную строчку кода, которая приводит к ошибке.

1. **Вывод текущего состояния программы** с помощью расположенных в критических точках программы операторов вывода (print) — в консоль, на экран (графическое отображение) или в файл. Вывод отладочных сведений в файл называется журналированием (логирование, написание лога - журнала).
2. **Использование отладчиков** — программных инструментов, позволяющих программисту наблюдать за пошаговым выполнением программы, останавливать и перезапускать её, прогонять в замедленном темпе, изменять значения в памяти и т.д.

# Использование отладчиков. Режим отладчика

- **Отладчик** — программный инструмент, позволяющий программисту наблюдать за выполнением исследуемой программы, останавливать и перезапускать её, прогонять в замедленном темпе, изменять значения в памяти и т.д.

# Комментирование и GOTO

> Простые методы отладки: В случае, если в программной среде нет отладчика, при этом программа достаточно тяжелая (требует много вычислительных/временных ресурсов) для полного её запуска в рамках отладки, перед запуском ограничивают код, который будет выполняться.

- **Комментирование** - превращение части кода в комментарии для того, чтобы интерпретатор/компилятор проигнорировал её.
- **Использование меток GOTO** - добавление в код специальных команд типа **GOTO**, при исполнении которых интерпретатор перескакивает к определённому месту (метке) в коде, исключая выполнение строк кода между командой и меткой.

# Отладка программы

Код с ошибкой вычисления:

```python
def f(x):
    return (q1 - 1)*x**2 + (p1 - 1)*x - m*j

DOTS_NUMBER = 10
a = float(input("введи a: "))
b = float(input("введи b: "))
c = float(input("введи c: "))
p = a * (tan(c) + 5)
q = (1 + (c**2)/2 + (b**2)/4)**0.
m = p
for i in range(10):
    m += a**q + ((p*a)**(1/3))/(q*a + p)
q += m
j = (sin(a) + cos(a))/(cos(a) - sin(a))*tan(a)
p1 = p * j
q1 = q * j
x_vector = [a + b*number for number in range(DOTS_NUMBER)]
y_vector = [f(x) for x in x_vector]
plt.plot(x_vector, y_vector)
plt.grid()
plt.show()
```

# Отладка программы

Исключаем часть программы и проверяем состояние переменных:

```python
def f(x):
    return (q1 - 1)*x**2 + (p1 - 1)*x - m*j

DOTS_NUMBER = 10
a = float(input("введи a: "))
b = float(input("введи b: "))
c = float(input("введи c: "))
p = a * (tan(c) + 5)
q = (1 + (c**2)/2 + (b**2)/4)**0.
m = p
for i in range(10):
    m += a**q + ((p*a)**(1/3))/(q*a + p)
q += m
print(p, q, m)
#j = (sin(a) + cos(a))/(cos(a) - sin(a))*tan(a)
#p1 = p * j
#q1 = q * j
#x_vector = [a + b*number for number in range(DOTS_NUMBER)]
#y_vector = [f(x) for x in x_vector]
#plt.plot(x_vector, y_vector)
#plt.grid()
#plt.show()
```

# Отладка программы

Если ошибка не найдена, повторяем:

```python
def f(x):
    return (q1 - 1)*x**2 + (p1 - 1)*x - m*j

DOTS_NUMBER = 10
a = float(input("введи a: "))
b = float(input("введи b: "))
c = float(input("введи c: "))
p = a * (tan(c) + 5)
q = (1 + (c**2)/2 + (b**2)/4)**0.
m = p
print(p, q, m)
#for i in range(10):
#    m += a**q + ((p*a)**(1/3))/(q*a + p)
#q += m
#j = (sin(a) + cos(a))/(cos(a) - sin(a))*tan(a)
#p1 = p * j
#q1 = q * j
#x_vector = [a + b*number for number in range(DOTS_NUMBER)]
#y_vector = [f(x) for x in x_vector]
#plt.plot(x_vector, y_vector)
#plt.grid()
#plt.show()
```

# Отладка программы

Можно посмотреть изменение состояния в динамике:

```python
def f(x):
    return (q1 - 1)*x**2 + (p1 - 1)*x - m*j

DOTS_NUMBER = 10
a = float(input("введи a: "))
b = float(input("введи b: "))
c = float(input("введи c: "))
p = a * (tan(c) + 5)
q = (1 + (c**2)/2 + (b**2)/4)**0.
m = p
print(p, q, m)
for i in range(10):
    m += a**q + ((p*a)**(1/3))/(q*a + p)
q += m
print(p, q, m)
#j = (sin(a) + cos(a))/(cos(a) - sin(a))*tan(a)
#p1 = p * j
#q1 = q * j
#x_vector = [a + b*number for number in range(DOTS_NUMBER)]
#y_vector = [f(x) for x in x_vector]
#plt.plot(x_vector, y_vector)
#plt.grid()
#plt.show()
```

# Вывод текущего состояния программы. Icecream

- Использование **print**

![print без icecream](print_bez_icecream.png)

- Использование **icecream**

![print с icecream](print_s_icecream.png)

```python
from icecream import ic
ic(p, q, m)
```

# Использование отладчиков. Режим отладчика PyCharm

| Изображение | Описание |
|-------------|----------|
| ![debugger1](debugger1.png) | 1. кнопка запуска программы в режиме отладки (debugging) <br> 2. метка 1, в которой программа остановится (ставится нажатием левой клавиши мыши справа от номера строки) <br> 3. метка 2 <br> 4. кнопки управления отладчиком: перейти к следующей метке, остановить, перезапустить и т.д. <br> 5. текущее состояние программы |

# Исключения (Exceptions)

- **Исключения** - объекты, возвращаемые программой (функцией, методом) при возникновении ошибки. Состоят из:
  1. Названия (тип ошибки). Например, **a/0** вернёт ZeroDivisionError - Деление на ноль, **3 + "4"** вернёт TypeError - неправильная работа с типами данных.
  2. Сообщение (текст ошибки). Например, "division by zero" и "can only concatenate str (not "int") to str" для двух примеров выше соответственно.
- В работу с исключениями входят:
  1. Создание исключений (В python можно вызвать командой **raise**)
  2. Обработка исключений
- Документация: [https://docs.python.org/3/tutorial/errors.html](https://docs.python.org/3/tutorial/errors.html)

# Встроенные исключения

- BaseException - базовое исключение, порождающее все остальные
- SystemExit - системное исключение, порождаемое функцией sys.exit при выходе из программы
- KeyboardInterrupt - системное исключение, порождаемое пользовательским выходом из программы с помощью сочетания клавиш
- ArithmeticError - арифметическая ошибка
- AssertionError - выражение assert ложно
- ImportError - ошибка импорта модуля или его атрибута
- IndexError - индекс не входит в диапазон элементов
- NameError - не найдено переменных с таким именем
- SyntaxError - ошибка синтаксиса
- TypeError - операция к объекту несоответствующего типа

# Создание исключений. Пример

> Посчитать формулу: $$f(x)=\frac{\sqrt{x}}{x-5}$$

```python
def f(x):
    return x**0.5/(x-5)
```

| Изображение | Описание |
|-------------|----------|
| ![Исключения1](isklucheniya1.png) | 1. **x=5** приводит к делению на ноль <br> 2. **x<0** приводит к корню из отрицательного числа (результат: комплексное число) |

# Создание исключений. Пример. Вариант 1

> Посчитать формулу: $$f(x)=\frac{\sqrt{x}}{x-5}$$

Мы хотим, чтобы:
1. При вводе числа 5, функция возвращала ошибку **ZeroDivisionError** (встроенное исключение) с сообщением: {деление на ноль}
2. При вводе отрицательных чисел, функция возвращала ошибку **NegativeSquareRoot** (созданное нами исключение) с сообщением: {отрицательное число под квадратным корнем}

```python
class NegativeSquareRoot(Exception):
    pass

def f(x):
    if x==5:
        raise ZeroDivisionError('Деление на ноль')
    elif x<0:
        raise NegativeSquareRoot('отрицательное число...')
    return x**0.5/(x-5)
```

![Исключения2](isklucheniya2.png)

# Обработка исключений. Пример. Вариант 2

> Посчитать формулу: $$f(x)=\frac{\sqrt{x}}{x-5}$$

Мы хотим, чтобы:
- Функция всегда возвращала численное значение
- При вводе отрицательного числа, **x** брался бы по модулю
- При вводе числа 5, использовалось число **x=5.001**

```python
def f(x):
    if x<0:
        x=abs(x)
    elif x==5:
        x+=0.001
    return x**0.5/(x-5)
```

| Изображение | Описание |
|-------------|----------|
| ![Исключения3](isklucheniya3.png) | |

# Обработка исключений. Конструкция try...except

- Использование условий **if** допустимо в случае, когда точно известны сценарии работы функции для любых исключений и при этом вероятность их появления существенна (50% и более). В этом подходе вначале проверяются исключения, после чего выполняется основной код.
- В общем случае используется конструкция **try...except**. При этом вначале будет произведена попытка выполнения основного кода. Если же возникнут ошибки (исключения), то будет произведена их обработка. Этот подход удобен, если выполнение основного кода не связано с ресурсозатратными операциями и вероятность появления исключений мала.
- Допускается комбинация **if** и **try...except**.
- try (англ.) - попробовать, except (англ.) - исключая, за исключением.

# Обработка исключений. Конструкция try...except

| Конструкция при вероятности ошибки меньше 50% | Конструкция при вероятности ошибки больше 50% |
|---------------------------------------------|---------------------------------------------|
| ```python | ```python |
| try: | if (△): |
| ○ # основной код | ... |
| except (△): | elif (△): |
| ... | ... |
| except (△): | elif (△): |
| ... | ... |
| except (△): | ○ # основной код |
| ... | ``` |

# Обработка исключений. Блок-схемы

| Блок-схема 1 | Блок-схема 2 |
|-------------|-------------|
| ![Блок-схема 1](block_diagram1.png) | ![Блок-схема 2](block_diagram2.png) |

# Создание исключений. Пример. Вариант 3

> Посчитать формулу: $$f(x)=\frac{\sqrt{x}}{x-5}$$

Мы хотим, чтобы:
1. При вводе числа 5, функция возвращала ошибку **ZeroDivisionError** (встроенное исключение) с сообщением: {деление на ноль}
2. При вводе отрицательных чисел, функция возвращала ошибку **NegativeSquareRoot** (созданное нами исключение) с сообщением: {отрицательное число под квадратным корнем}
3. При возникновении любых других ошибок возвращалось исключение **Exception** (Самое общее исключение) с сообщением: {Неизвестная ошибка}

```python
class NegativeSquareRoot(Exception):
    pass

def f(x):
    try:
        if x < 0:
            raise NegativeSquareRoot
        return x**0.5/(x-5)
    except NegativeSquareRoot:
        raise NegativeSquareRoot('отрицательное число...')
    except ZeroDivisionError:
        raise ZeroDivisionError('деление на ноль')
    except Exception:
        raise Exception('Неизвестная ошибка')
```

![Исключения4](isklucheniya4.png)

# Обработка исключений. Пример. Вариант 4

> Посчитать формулу: $$f(x)=\frac{\sqrt{x}}{x-5}$$

Мы хотим, чтобы:
- Функция всегда возвращала численное значение
- При вводе отрицательного числа, **x** брался бы по модулю
- При вводе числа 5, использовалось число **x=5.001**
- При возникновении любых других ошибок возвращалось значение -999

```python
def f(x):
    try:
        if x < 0:
            raise NegativeSquareRoot
        return x**0.5/(x-5)
    except NegativeSquareRoot:
        x = abs(x)
        return x**0.5/(x-5)
    except ZeroDivisionError:
        x += 0.001
        return x**0.5/(x-5)
    except Exception:
        return -999
```

| Изображение | Описание |
|-------------|----------|
| ![Исключения5](isklucheniya5.png) | |

# Создание и обработка исключений. Пример. Вариант 5

```python
def f(x):
    try:
        if x < 0:
            raise NegativeSquareRoot
        return x**0.5/(x-5)
    except NegativeSquareRoot:
        raise NegativeSquareRoot('отрицательное число...')
    except ZeroDivisionError:
        raise ZeroDivisionError('деление на ноль')
    except Exception:
        raise Exception('Неизвестная ошибка')

while True:
    try:
        y = int(input('Введите число: '))
        print("Значение функции равно {:.4f}".format(f(y)))
        break
    except Exception:
        print('Неверное число, повторите ввод')
```

![Исключения6](isklucheniya6.png)

# Летучка

- Что такое отступы, интервалы, поля, колонтитулы?
- Напишите функцию Excel (в виде ссылок на ячейки) для вычисления выражения: $$y=x^2-sin(\pi x)+c, \quad c=const$$
- Нарисуйте в табличном виде алгоритм подсчёта количества квадратных чисел (перебор не менее 10 чисел начиная от 1)
  - квадратные числа - числа, которые являются квадратами целых чисел

